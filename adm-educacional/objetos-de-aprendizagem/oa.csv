Disciplina;Nome;Tipo;Descrição
Banco de Dados I;Videoaula: Introdução ao Modelo Entidade-Relacionamento;Vídeo;Este vídeo introdutório aborda os conceitos essenciais do **Modelo Entidade-Relacionamento (MER)**, fundamental para a fase de modelagem conceitual de bancos de dados. Ele explica em detalhes o que são entidades, como definir seus atributos e, mais importante, como estabelecer os relacionamentos entre diferentes entidades, servindo como base para a criação de um diagrama ER.
Banco de Dados I;Exercício Interativo: Identificação de Cardinalidades;Quiz;Este quiz interativo oferece diversos cenários práticos onde o aluno deve analisar os requisitos e determinar a **cardinalidade correta** (um para um, um para muitos ou muitos para muitos) dos relacionamentos propostos. O objetivo é aprimorar a capacidade de traduzir a lógica de negócios em regras de modelagem de dados precisas, fornecendo feedback imediato para cada resposta.
Banco de Dados I;Simulação: Normalização de um Banco de Dados;Simulação;A simulação permite que o usuário carregue um esquema de banco de dados desnormalizado e aplique interativamente as principais formas normais: **1FN, 2FN e 3FN**. O sistema visualiza as dependências funcionais e ajuda o aluno a identificar e eliminar anomalias de inserção, exclusão e atualização, reforçando a importância da integridade e organização dos dados.
Banco de Dados I;Infográfico: Tipos de Dados SQL;Infográfico;Um guia visual e fácil de consultar sobre os principais **tipos de dados** utilizados em SQL, como VARCHAR, INT, DATE, BOOLEAN e DECIMAL. O infográfico explica a aplicação e as restrições de cada tipo, auxiliando o aluno na escolha correta dos tipos ao definir o esquema da tabela.
Banco de Dados I;Estudo de Caso: Modelagem para E-commerce;Estudo de Caso;Este estudo apresenta o desafio de modelar o banco de dados para um sistema de comércio eletrônico, envolvendo complexidades como catálogo de produtos, pedidos, clientes e estoque. O material detalha a **solução de modelagem proposta**, incluindo como lidar com o relacionamento entre produtos e categorias.
Banco de Dados I;Exemplo de Código: Views e Índices;Exemplo de Código;O código demonstra a criação e o uso de **Views** (tabelas virtuais) para simplificar consultas complexas e ocultar a complexidade do esquema subjacente. Além disso, mostra como criar **Índices** para melhorar o desempenho de recuperação de dados em colunas frequentemente consultadas.
Banco de Dados I;Mini-Game: Identifique a Forma Normal;Jogo;O jogo desafia o aluno a analisar diferentes esquemas de tabelas e classificar a **Forma Normal** em que se encontram (1FN, 2FN, 3FN). O objetivo é identificar a presença de dependências funcionais parciais ou transitivas para determinar se o esquema precisa ser desmembrado.
Banco de Dados I;Videoaula: Transações e ACID;Vídeo;A videoaula explica o conceito de **Transações** como uma unidade lógica de trabalho em um banco de dados. O foco principal é detalhar as quatro propriedades **ACID** (**A**tomicidade, **C**onsistência, **I**solamento, **D**urabilidade), que garantem a confiabilidade e integridade dos dados, especialmente em ambientes multiusuário.
Banco de Dados I;Fórum de Discussão: Otimização de Consultas SQL;Fórum;Um espaço para os alunos compartilharem e discutirem técnicas de **otimização de consultas SQL** e melhoria de desempenho. Os tópicos incluem o uso correto de índices, a reescrita de subconsultas complexas e a análise do plano de execução (EXPLAIN PLAN) gerado pelo sistema gerenciador de banco de dados.
Algoritmos e Estruturas de Dados;Exemplo de Código: Merge Sort em Python;Exemplo de Código;O código demonstra a implementação do algoritmo de ordenação **Merge Sort** em Python, destacando a estratégia de **dividir e conquistar**. A explicação se concentra na função de *merge* (combinação), que é a etapa crucial para a ordenação eficiente.
Algoritmos e Estruturas de Dados;Mini-Game: Resolva o Labirinto (Busca em Largura/Profundidade);Jogo;Um desafio gamificado onde o aluno deve aplicar mentalmente (ou visualmente) os algoritmos de travessia de grafos **Busca em Largura (BFS)** e **Busca em Profundidade (DFS)** para encontrar a saída em um labirinto, entendendo a diferença entre a exploração por nível e por ramo.
Algoritmos e Estruturas de Dados;Fórum de Discussão: Algoritmos de Ordenação Estáveis e Instáveis;Fórum;Um espaço para debater a propriedade de **estabilidade** em algoritmos de ordenação. Os alunos discutem a diferença entre algoritmos **estáveis** (que mantêm a ordem relativa de elementos com chaves iguais) e **instáveis**, analisando exemplos como Merge Sort (estável) vs. Quick Sort (instável).
Algoritmos e Estruturas de Dados;Guia Rápido: Implementação de Tries (Árvore de Prefixo);Documento;Um guia focado na estrutura de dados **Trie (Árvore de Prefixo)**. Ele explica como a Trie é utilizada para armazenar cadeias de caracteres de forma eficiente, otimizando operações como busca e autocompletar, e detalha a estrutura de nós e referências.
Algoritmos e Estruturas de Dados;Laboratório Virtual: Algoritmo de Busca Binária;Laboratório;Neste ambiente, o aluno é guiado na implementação da **Busca Binária**, tanto na versão recursiva quanto na iterativa, em um vetor previamente ordenado. A prática visa reforçar a lógica de dividir e conquistar, que reduz drasticamente o tempo de busca ($O(\log n)$).
Algoritmos e Estruturas de Dados;Infográfico: Estruturas de Dados Lineares vs. Não Lineares;Infográfico;Um diagrama que esclarece a diferença conceitual e estrutural entre as **Estruturas Lineares** (onde os elementos formam uma sequência, como Listas e Pilhas) e as **Estruturas Não Lineares** (onde os elementos se ramificam, como Árvores e Grafos).
Algoritmos e Estruturas de Dados;Estudo de Caso: Compressão de Dados com Árvore de Huffman;Estudo de Caso;O material explica como a estrutura da **Árvore de Huffman** é utilizada em algoritmos de compressão de dados. Ele mostra o processo de construção da árvore com base nas frequências dos caracteres e como ela gera códigos de comprimento variável para obter a compressão.
Algoritmos e Estruturas de Dados;Exemplo de Código: Merge Sort em Python;Exemplo de Código;O código demonstra a implementação do algoritmo de ordenação **Merge Sort** em Python, destacando a estratégia de **dividir e conquistar**. A explicação se concentra na função de *merge* (combinação), que é a etapa crucial para a ordenação eficiente.
Algoritmos e Estruturas de Dados;Mini-Game: Resolva o Labirinto (Busca em Largura/Profundidade);Jogo;Um desafio gamificado onde o aluno deve aplicar mentalmente (ou visualmente) os algoritmos de travessia de grafos **Busca em Largura (BFS)** e **Busca em Profundidade (DFS)** para encontrar a saída em um labirinto, entendendo a diferença entre a exploração por nível e por ramo.
Programação Orientada a Objetos;Videoaula: Princípios SOLID com Exemplos em Java;Vídeo;Esta videoaula aborda em profundidade os cinco princípios de design **SOLID**, essenciais para a construção de software orientado a objetos robusto e de fácil manutenção. Cada princípio é detalhado com exemplos práticos e refatorações de código em **Java**, mostrando como aplicá-los para evitar "código cheiroso" (code smells).
Programação Orientada a Objetos;Simulação: Diagrama de Classes UML Interativo;Simulação;Uma ferramenta interativa que permite ao aluno desenhar visualmente **Diagramas de Classes UML**, definindo classes, atributos, métodos e os tipos de relacionamento (herança, agregação, composição). O sistema pode, então, gerar um esqueleto de código básico em **Java ou C#** a partir do diagrama.
Programação Orientada a Objetos;Exercício Interativo: Identificação de Padrões de Projeto;Quiz;O quiz desafia o aluno a analisar um problema de design de software e selecionar o **Padrão de Projeto (Design Pattern)** mais apropriado para a solução (e.g., Singleton para garantir uma única instância, Factory para criar objetos). O foco é aplicar o conhecimento de POO para resolver problemas recorrentes.
Programação Orientada a Objetos;Laboratório Virtual: Implementação de Interfaces e Classes Abstratas;Laboratório;Neste ambiente de codificação, o aluno pratica a implementação de **Interfaces** para definir contratos e o uso de **Classes Abstratas** para fornecer implementações parciais. O objetivo é reforçar a importância da Abstração e do Polimorfismo no design de sistemas POO.
Programação Orientada a Objetos;Infográfico: Os Pilares da POO (Java);Infográfico;Uma representação visual clara dos quatro pilares fundamentais da Programação Orientada a Objetos: **Encapsulamento, Herança, Polimorfismo e Abstração**. O material usa exemplos concisos em **Java** para ilustrar como cada pilar contribui para a modularidade e flexibilidade do código.
Programação Orientada a Objetos;Estudo de Caso: Refatoração de Código para POO;Estudo de Caso;O material apresenta um trecho de código que segue o paradigma procedural e desafia o aluno a **refatorá-lo** completamente, aplicando os princípios de **POO** (criação de classes, encapsulamento de estado e definição de métodos) para torná-lo mais legível e manutenível.
Programação Orientada a Objetos;Exemplo de Código: Tratamento de Exceções (Try-Catch-Finally);Exemplo de Código;Um conjunto de exemplos de código em **Java e C#** demonstrando a sintaxe e a prática de um **tratamento de exceções** robusto usando os blocos **try, catch** e **finally**. O foco é ensinar a lidar com erros inesperados e a garantir a estabilidade do programa.
Programação Orientada a Objetos;Mini-Game: Associe Conceito e Código;Jogo;O jogo desafia o aluno a fazer a correspondência correta entre um conceito avançado de POO (e.g., "Herança", "Associação") e o respectivo **trecho de código Java/C#** que o implementa. É uma forma rápida de testar o reconhecimento e a aplicação prática dos conceitos.
Programação Orientada a Objetos;Fórum de Discussão: Injeção de Dependência (DI);Fórum;Um espaço para os alunos discutirem o conceito e os benefícios da **Injeção de Dependência (DI)**. O debate se concentra em como o DI ajuda a desacoplar componentes, a aplicar o princípio Inversão de Dependência (DIP) do SOLID e a facilitar testes unitários.