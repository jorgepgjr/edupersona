Disciplina;Nome;Tipo;Descrição
Banco de Dados I;Videoaula: Introdução ao Modelo Entidade-Relacionamento;Vídeo;Este vídeo introdutório aborda os conceitos essenciais do **Modelo Entidade-Relacionamento (MER)**, fundamental para a fase de modelagem conceitual de bancos de dados. Ele explica em detalhes o que são entidades, como definir seus atributos e, mais importante, como estabelecer os relacionamentos entre diferentes entidades, servindo como base para a criação de um diagrama ER.
Banco de Dados I;Exercício Interativo: Identificação de Cardinalidades;Quiz;Este quiz interativo oferece diversos cenários práticos onde o aluno deve analisar os requisitos e determinar a **cardinalidade correta** (um para um, um para muitos ou muitos para muitos) dos relacionamentos propostos. O objetivo é aprimorar a capacidade de traduzir a lógica de negócios em regras de modelagem de dados precisas, fornecendo feedback imediato para cada resposta.
Banco de Dados I;Simulação: Normalização de um Banco de Dados;Simulação;A simulação permite que o usuário carregue um esquema de banco de dados desnormalizado e aplique interativamente as principais formas normais: **1FN, 2FN e 3FN**. O sistema visualiza as dependências funcionais e ajuda o aluno a identificar e eliminar anomalias de inserção, exclusão e atualização, reforçando a importância da integridade e organização dos dados.
Banco de Dados I;Guia Rápido: Comandos Básicos DDL (CREATE, DROP, ALTER);Documento;Este guia conciso é um recurso de referência para os comandos da **Linguagem de Definição de Dados (DDL)**. Ele apresenta a sintaxe e exemplos claros de como usar **CREATE** para criar tabelas e índices, **DROP** para remover objetos e **ALTER** para modificar a estrutura do esquema, sendo essencial para a construção e manutenção do banco de dados.
Banco de Dados I;Laboratório Virtual: Consultas SQL Básicas (SELECT, WHERE);Laboratório;Neste ambiente de laboratório virtual, o aluno pode executar comandos **SQL** em um banco de dados de exemplo pré-configurado. O foco é a prática das cláusulas **SELECT** para recuperação de dados e **WHERE** para aplicação de filtros, permitindo a experimentação imediata e a visualização dos resultados das consultas mais fundamentais.
Banco de Dados I;Infográfico: Passos da Modelagem Conceitual à Lógica;Infográfico;Este material visualiza o fluxo completo do processo de **modelagem de dados**, desde o levantamento inicial de requisitos até a criação do esquema relacional final. Ele destaca as transições chave, como a conversão do Diagrama ER (conceitual) para o Modelo Relacional (lógico), oferecendo uma visão holística e estruturada do ciclo de vida da modelagem.
Banco de Dados I;Estudo de Caso: Modelagem de um Sistema de Biblioteca;Estudo de Caso;O material apresenta um cenário real detalhado de um sistema de gerenciamento de biblioteca, exigindo que o aluno aplique os conceitos de **Modelagem ER** para projetar a estrutura de dados. O estudo inclui a descrição dos requisitos, a solução de modelagem proposta e a justificativa para a escolha das entidades, atributos e relacionamentos.
Banco de Dados I;Exemplo de Código: Subconsultas e Joins;Exemplo de Código;Uma coleção de trechos de código SQL comentados que demonstram o uso avançado da cláusula **JOIN** (INNER, LEFT, RIGHT) e a aplicação de **subconsultas** (queries aninhadas) no banco de dados. O foco é mostrar como combinar dados de múltiplas tabelas e como usar o resultado de uma consulta como entrada para outra, resolvendo problemas complexos de recuperação.
Banco de Dados I;Mini-Game: Construa sua Query SQL;Jogo;Este mini-game transforma a escrita de consultas SQL em um desafio divertido, onde o usuário deve **arrastar e soltar cláusulas SQL** (SELECT, FROM, WHERE, GROUP BY) na ordem correta para construir uma query válida que resolva um problema apresentado. Ele ajuda a fixar a sintaxe e a lógica de construção de sentenças SQL.
Banco de Dados I;Fórum de Discussão: Vantagens e Desvantagens do Modelo Relacional;Fórum;Este espaço é dedicado ao debate e à troca de ideias sobre as **características e limitações do Modelo Relacional** em comparação com modelos não-relacionais (NoSQL). Os alunos são encorajados a discutir as situações em que o modelo relacional é ideal (integridade, transações) e quando pode ser limitante (escalabilidade, dados não estruturados).
Banco de Dados I;Videoaula: Agregação e Group By;Vídeo;A videoaula se concentra em como usar as **funções de agregação SQL** como **SUM, AVG, COUNT, MIN e MAX** para resumir dados. Além disso, ela explica em detalhes a aplicação da cláusula **GROUP BY** para agrupar linhas com valores idênticos, permitindo que as funções de agregação sejam aplicadas a cada grupo.
Banco de Dados I;Exercício Interativo: Mapeamento ER para Relacional;Quiz;O exercício desafia o aluno a converter visualmente um **Diagrama Entidade-Relacionamento** em um esquema de tabelas relacional. Isso inclui a correta definição das tabelas, a escolha das colunas, a aplicação de **chaves primárias** e a criação de **chaves estrangeiras** para implementar os relacionamentos.
Banco de Dados I;Guia Rápido: Comandos DML (INSERT, UPDATE, DELETE);Documento;Um documento de referência focado na **Linguagem de Manipulação de Dados (DML)**. Ele fornece a sintaxe e exemplos práticos dos comandos essenciais para gerenciar os dados dentro das tabelas: **INSERT** para adicionar novos registros, **UPDATE** para modificar dados existentes e **DELETE** para remover registros.
Banco de Dados I;Laboratório Virtual: Manipulação de Chaves Estrangeiras;Laboratório;O ambiente de laboratório permite a prática de criação e manipulação de **chaves estrangeiras (FOREIGN KEY)**, enfatizando a importância das **restrições de integridade referencial**. O aluno experimenta como o banco de dados impõe regras para garantir que os dados relacionados permaneçam consistentes.
Banco de Dados I;Infográfico: Tipos de Dados SQL;Infográfico;Um guia visual e fácil de consultar sobre os principais **tipos de dados** utilizados em SQL, como VARCHAR, INT, DATE, BOOLEAN e DECIMAL. O infográfico explica a aplicação e as restrições de cada tipo, auxiliando o aluno na escolha correta dos tipos ao definir o esquema da tabela.
Banco de Dados I;Estudo de Caso: Modelagem para E-commerce;Estudo de Caso;Este estudo apresenta o desafio de modelar o banco de dados para um sistema de comércio eletrônico, envolvendo complexidades como catálogo de produtos, pedidos, clientes e estoque. O material detalha a **solução de modelagem proposta**, incluindo como lidar com o relacionamento entre produtos e categorias.
Banco de Dados I;Exemplo de Código: Views e Índices;Exemplo de Código;O código demonstra a criação e o uso de **Views** (tabelas virtuais) para simplificar consultas complexas e ocultar a complexidade do esquema subjacente. Além disso, mostra como criar **Índices** para melhorar o desempenho de recuperação de dados em colunas frequentemente consultadas.
Banco de Dados I;Mini-Game: Identifique a Forma Normal;Jogo;O jogo desafia o aluno a analisar diferentes esquemas de tabelas e classificar a **Forma Normal** em que se encontram (1FN, 2FN, 3FN). O objetivo é identificar a presença de dependências funcionais parciais ou transitivas para determinar se o esquema precisa ser desmembrado.
Banco de Dados I;Videoaula: Transações e ACID;Vídeo;A videoaula explica o conceito de **Transações** como uma unidade lógica de trabalho em um banco de dados. O foco principal é detalhar as quatro propriedades **ACID** (**A**tomicidade, **C**onsistência, **I**solamento, **D**urabilidade), que garantem a confiabilidade e integridade dos dados, especialmente em ambientes multiusuário.
Banco de Dados I;Fórum de Discussão: Otimização de Consultas SQL;Fórum;Um espaço para os alunos compartilharem e discutirem técnicas de **otimização de consultas SQL** e melhoria de desempenho. Os tópicos incluem o uso correto de índices, a reescrita de subconsultas complexas e a análise do plano de execução (EXPLAIN PLAN) gerado pelo sistema gerenciador de banco de dados.
Algoritmos e Estruturas de Dados;Videoaula: Conceitos e Implementação de Listas Encadeadas;Vídeo;Esta aula explora a estrutura de dados de **Listas Encadeadas (Linked Lists)**, explicando a diferença fundamental entre ela e arrays (alocação dinâmica). O vídeo detalha as operações de inserção, exclusão e travessia, mostrando a implementação com foco na manipulação de ponteiros (referências).
Algoritmos e Estruturas de Dados;Simulação: Pilhas e Filas em Ação;Simulação;A ferramenta permite visualizar e interagir com as operações de **Pilhas (Stack - LIFO)** e **Filas (Queue - FIFO)**. O usuário pode simular a adição (push/enqueue) e a remoção (pop/dequeue) de elementos, observando como o princípio de acesso de cada estrutura de dados é aplicado dinamicamente.
Algoritmos e Estruturas de Dados;Exercício Interativo: Rastreio de Algoritmos de Ordenação;Quiz;O quiz apresenta um array desordenado e solicita que o aluno **rastreie as etapas** intermediárias de algoritmos de ordenação como **Bubble Sort, Selection Sort e Insertion Sort**. O objetivo é verificar a compreensão da lógica interna e do movimento dos elementos durante o processo de ordenação.
Algoritmos e Estruturas de Dados;Guia Rápido: Complexidade Assintótica (Notação O);Documento;Este guia introduz a **Notação O grande (Big O)** como a ferramenta padrão para analisar a eficiência de algoritmos. Ele fornece exemplos de diferentes classes de complexidade ($O(1)$, $O(\log n)$, $O(n)$, $O(n^2)$) e explica como determinar o desempenho de um algoritmo em função do tamanho da entrada ($n$).
Algoritmos e Estruturas de Dados;Laboratório Virtual: Implementação de Árvores Binárias;Laboratório;Um ambiente de programação online onde o aluno pratica a implementação das operações básicas em uma **Árvore Binária de Busca (ABB)**. O foco está nas funções de inserção de nós, busca de valores e as diferentes formas de travessia (pré-ordem, em-ordem e pós-ordem).
Algoritmos e Estruturas de Dados;Infográfico: Comparativo de Algoritmos de Busca;Infográfico;Uma representação visual que compara as características e o desempenho (em termos de complexidade de tempo) da **Busca Linear** e da **Busca Binária**. O infográfico destaca as condições de aplicação (vetor ordenado para a Busca Binária) e as vantagens de cada método.
Algoritmos e Estruturas de Dados;Estudo de Caso: Escolha da Estrutura de Dados em um Jogo;Estudo de Caso;O material apresenta um problema prático no desenvolvimento de um jogo (e.g., gerenciamento de inventário ou pathfinding), exigindo que o aluno **justifique a escolha** de uma estrutura de dados específica (e.g., Heap, Grafo, Lista) para otimizar o desempenho do recurso.
Algoritmos e Estruturas de Dados;Exemplo de Código: Algoritmo Quick Sort em C;Exemplo de Código;Um exemplo de código bem comentado do algoritmo de ordenação **Quick Sort** implementado na linguagem C. O foco da explicação é o processo de **partição** e a natureza recursiva do algoritmo, destacando como ele alcança um alto desempenho médio.
Algoritmos e Estruturas de Dados;Mini-Game: Conecte os Nós da Estrutura;Jogo;Neste jogo, o aluno é desafiado a **conectar nós** (elementos) na ordem correta, simulando a criação e manipulação de estruturas de dados complexas, como **Listas Duplamente Encadeadas** ou a representação de **Grafos** por lista de adjacências, fixando o conceito de ponteiros.
Algoritmos e Estruturas de Dados;Fórum de Discussão: Implementação de Tabela Hash;Fórum;O fórum é dedicado à discussão sobre a implementação eficiente de **Tabelas Hash (Hash Tables)**. Os tópicos incluem a escolha de boas funções de hashing e a análise das diferentes **técnicas de tratamento de colisões**, como encadeamento separado (separate chaining) e sondagem linear (linear probing).
Algoritmos e Estruturas de Dados;Videoaula: Grafos e Algoritmos de Caminho Mínimo;Vídeo;A aula introduz o conceito de **Grafos** (estruturas não-lineares) e suas aplicações. O foco principal é a explanação passo a passo do algoritmo de **Dijkstra**, usado para encontrar o **caminho mais curto** entre um nó de origem e todos os outros nós em um grafo com pesos não negativos.
Algoritmos e Estruturas de Dados;Simulação: Heap Sort;Simulação;Uma ferramenta interativa que demonstra as fases do algoritmo **Heap Sort**. A simulação visualiza a construção inicial do **Heap** (estrutura de árvore binária quase completa) e as etapas sucessivas de extração do elemento máximo, mostrando como a propriedade de heap é mantida.
Algoritmos e Estruturas de Dados;Exercício Interativo: Análise de Recorrência;Quiz;Este exercício foca em algoritmos recursivos, desafiando o aluno a encontrar a **relação de recorrência** que descreve o tempo de execução e, em seguida, a resolvê-la para determinar a **complexidade assintótica** do algoritmo, utilizando técnicas como o Teorema Mestre.
Algoritmos e Estruturas de Dados;Guia Rápido: Implementação de Tries (Árvore de Prefixo);Documento;Um guia focado na estrutura de dados **Trie (Árvore de Prefixo)**. Ele explica como a Trie é utilizada para armazenar cadeias de caracteres de forma eficiente, otimizando operações como busca e autocompletar, e detalha a estrutura de nós e referências.
Algoritmos e Estruturas de Dados;Laboratório Virtual: Algoritmo de Busca Binária;Laboratório;Neste ambiente, o aluno é guiado na implementação da **Busca Binária**, tanto na versão recursiva quanto na iterativa, em um vetor previamente ordenado. A prática visa reforçar a lógica de dividir e conquistar, que reduz drasticamente o tempo de busca ($O(\log n)$).
Algoritmos e Estruturas de Dados;Infográfico: Estruturas de Dados Lineares vs. Não Lineares;Infográfico;Um diagrama que esclarece a diferença conceitual e estrutural entre as **Estruturas Lineares** (onde os elementos formam uma sequência, como Listas e Pilhas) e as **Estruturas Não Lineares** (onde os elementos se ramificam, como Árvores e Grafos).
Algoritmos e Estruturas de Dados;Estudo de Caso: Compressão de Dados com Árvore de Huffman;Estudo de Caso;O material explica como a estrutura da **Árvore de Huffman** é utilizada em algoritmos de compressão de dados. Ele mostra o processo de construção da árvore com base nas frequências dos caracteres e como ela gera códigos de comprimento variável para obter a compressão.
Algoritmos e Estruturas de Dados;Exemplo de Código: Merge Sort em Python;Exemplo de Código;O código demonstra a implementação do algoritmo de ordenação **Merge Sort** em Python, destacando a estratégia de **dividir e conquistar**. A explicação se concentra na função de *merge* (combinação), que é a etapa crucial para a ordenação eficiente.
Algoritmos e Estruturas de Dados;Mini-Game: Resolva o Labirinto (Busca em Largura/Profundidade);Jogo;Um desafio gamificado onde o aluno deve aplicar mentalmente (ou visualmente) os algoritmos de travessia de grafos **Busca em Largura (BFS)** e **Busca em Profundidade (DFS)** para encontrar a saída em um labirinto, entendendo a diferença entre a exploração por nível e por ramo.
Algoritmos e Estruturas de Dados;Fórum de Discussão: Algoritmos de Ordenação Estáveis e Instáveis;Fórum;Um espaço para debater a propriedade de **estabilidade** em algoritmos de ordenação. Os alunos discutem a diferença entre algoritmos **estáveis** (que mantêm a ordem relativa de elementos com chaves iguais) e **instáveis**, analisando exemplos como Merge Sort (estável) vs. Quick Sort (instável).
Programação Orientada a Objetos;Videoaula: Princípios SOLID com Exemplos em Java;Vídeo;Esta videoaula aborda em profundidade os cinco princípios de design **SOLID**, essenciais para a construção de software orientado a objetos robusto e de fácil manutenção. Cada princípio é detalhado com exemplos práticos e refatorações de código em **Java**, mostrando como aplicá-los para evitar "código cheiroso" (code smells).
Programação Orientada a Objetos;Simulação: Diagrama de Classes UML Interativo;Simulação;Uma ferramenta interativa que permite ao aluno desenhar visualmente **Diagramas de Classes UML**, definindo classes, atributos, métodos e os tipos de relacionamento (herança, agregação, composição). O sistema pode, então, gerar um esqueleto de código básico em **Java ou C#** a partir do diagrama.
Programação Orientada a Objetos;Exercício Interativo: Identificação de Padrões de Projeto;Quiz;O quiz desafia o aluno a analisar um problema de design de software e selecionar o **Padrão de Projeto (Design Pattern)** mais apropriado para a solução (e.g., Singleton para garantir uma única instância, Factory para criar objetos). O foco é aplicar o conhecimento de POO para resolver problemas recorrentes.
Programação Orientada a Objetos;Guia Rápido: Sobrescrita vs. Sobrecarga em C#;Documento;Um recurso de referência que traça um comparativo direto entre os conceitos de **Sobrescrita (Overriding)** e **Sobrecarga (Overloading)** de métodos na linguagem **C#**. O guia explica quando usar cada técnica e como elas se relacionam com o Polimorfismo.
Programação Orientada a Objetos;Laboratório Virtual: Implementação de Interfaces e Classes Abstratas;Laboratório;Neste ambiente de codificação, o aluno pratica a implementação de **Interfaces** para definir contratos e o uso de **Classes Abstratas** para fornecer implementações parciais. O objetivo é reforçar a importância da Abstração e do Polimorfismo no design de sistemas POO.
Programação Orientada a Objetos;Infográfico: Os Pilares da POO (Java);Infográfico;Uma representação visual clara dos quatro pilares fundamentais da Programação Orientada a Objetos: **Encapsulamento, Herança, Polimorfismo e Abstração**. O material usa exemplos concisos em **Java** para ilustrar como cada pilar contribui para a modularidade e flexibilidade do código.
Programação Orientada a Objetos;Estudo de Caso: Refatoração de Código para POO;Estudo de Caso;O material apresenta um trecho de código que segue o paradigma procedural e desafia o aluno a **refatorá-lo** completamente, aplicando os princípios de **POO** (criação de classes, encapsulamento de estado e definição de métodos) para torná-lo mais legível e manutenível.
Programação Orientada a Objetos;Exemplo de Código: Tratamento de Exceções (Try-Catch-Finally);Exemplo de Código;Um conjunto de exemplos de código em **Java e C#** demonstrando a sintaxe e a prática de um **tratamento de exceções** robusto usando os blocos **try, catch** e **finally**. O foco é ensinar a lidar com erros inesperados e a garantir a estabilidade do programa.
Programação Orientada a Objetos;Mini-Game: Associe Conceito e Código;Jogo;O jogo desafia o aluno a fazer a correspondência correta entre um conceito avançado de POO (e.g., "Herança", "Associação") e o respectivo **trecho de código Java/C#** que o implementa. É uma forma rápida de testar o reconhecimento e a aplicação prática dos conceitos.
Programação Orientada a Objetos;Fórum de Discussão: Injeção de Dependência (DI);Fórum;Um espaço para os alunos discutirem o conceito e os benefícios da **Injeção de Dependência (DI)**. O debate se concentra em como o DI ajuda a desacoplar componentes, a aplicar o princípio Inversão de Dependência (DIP) do SOLID e a facilitar testes unitários.